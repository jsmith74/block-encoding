\documentclass[aps,pra,twocolumn,showpacs,superscriptaddress,floatfix,10pt]{revtex4}
\usepackage{graphicx}
\usepackage{psfrag}
\usepackage{amssymb,amsmath}
\usepackage{physics}
\usepackage{float}
\usepackage{dsfont}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
%\usepackage[dvips]{color}
\algdef{SE}[DOWHILE]{Do}{doWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}%

%\setlength{\topmargin}{0.1cm}
\begin{document}
\newcommand{\beq}{\begin{equation}}
\newcommand{\eeq}{\end{equation}}
\newcommand{\ben}{\begin{eqnarray}}
\newcommand{\een}{\end{eqnarray}}
\newcommand{\bea}{\begin{array}}
\newcommand{\eea}{\end{array}}
\newcommand{\om}{(\omega )}
\newcommand{\bef}{\begin{figure}}
\newcommand{\eef}{\end{figure}}
\newcommand{\leg}[1]{\caption{\protect\rm{\protect\footnotesize{#1}}}}
\newcommand{\ew}[1]{\langle{#1}\rangle}
\newcommand{\be}[1]{\mid\!{#1}\!\mid}
\newcommand{\no}{\nonumber}
\newcommand{\etal}{{\em et~al }}
\newcommand{\geff}{g_{\mbox{\it{\scriptsize{eff}}}}}
\newcommand{\da}[1]{{#1}^\dagger}
\newcommand{\cf}{{\it cf.\/}\ }
\newcommand{\ie}{{\it i.e.\/}\ }   

\newcommand{\spazio}{\vspace{0.3cm}}%{\vspace{1.05cm}}
\hyphenation{bio-mol-ecules}
\newcommand{\de}[1]{\frac{\partial}{\partial{#1}}}
\newcommand{\U}{\tilde{U}}
\newcommand{\V}{\tilde{V}}


\title{Optimal Construction of Elementary Entangling Operations between Deterministic Blocks of Rail Encoded Linear Optical Qubits}

\author{Jake~A.~Smith}
\affiliation{Tulane University, Department of Physics, New Orleans, Louisiana 70118, USA}

\author{Lev Kaplan}
\affiliation{Tulane University, Department of Physics, New Orleans, Louisiana 70118, USA}

 \begin{abstract}
Here, we numerically simulate probabilistic elementary entangling operations between rail encoded photons for the purpose of scalable universal quantum computation or communication. We propose grouping logical qubits into single photon blocks wherein all quantum logic operations are deterministic and straightforward to implement. Inter-block communication is then allowed through said entangling operations. We find a promising trend in the increasing probability of successful inter-block communication as we increase the size of our entangling operations.
\end{abstract}                                                               
\date{\today}
\pacs{***}
\maketitle

\section{Basic Mathematical Principles}
\label{Intro}
An optical quantum state of $N$ photons contained in $M$ optical modes can be written in the Fock basis,
\begin{eqnarray}
	\label{LO State Fock Basis}
	\ket{\psi} = c_1 \ket{N,0,\dots,0_M} + c_2 \ket{N-1,1,0,\dots, 0_M} + \\* \dots  + c_{d_H} \ket{0,0,\dots,N_M}	\nonumber \quad \quad \quad \quad
\end{eqnarray}
We note that the Hilbert space dimension of such a state is given by
\begin{equation}
\label{Hilbert Space Dimension}
	d_H = \frac{(N+M-1)!}{N!(M-1)!}
\end{equation}
or the number of ways to order $N$ indistinguishable photons and $M-1$ partitions.

A linear optical operation acting on such a state is generally described by the transformation of creation operators:
\begin{equation}
\label{LO Creation Operator Transformation}
\hat{a}^\dagger_\alpha \rightarrow \sum_{\beta=1}^{M} U_{\alpha\beta} \hat{a}^\dagger_\beta
\end{equation}
where $U_{\alpha \beta}$ are the elements of some unitary complex matrix, $U$. Thus, one typically converts a state in the form of~(\ref{LO State Fock Basis}) into
\begin{eqnarray}
\ket{\psi} = \Big(c_1 \frac{(\hat{a}^\dagger_1)^N}{\sqrt{N!}} + c_2 \frac{ (\hat{a}^\dagger_1)^{N-1} \hat{a}^\dagger_2}{\sqrt{(N-1)!}} + \dots \\* + c_{d_H} \frac{(\hat{a}^\dagger_M)^N}{\sqrt{N!}}\Big) \ket{0,0,\dots,0_M} \quad \quad \nonumber
\end{eqnarray}
and applies the symbolic transformation~(\ref{LO Creation Operator Transformation}). This process may be fine for an optical circuit of few components and small $N$ and $M$, but transforming the creation operators for large systems can otherwise become intractable. 

Instead, we present a highly efficient numerical protocol for simulating linear optical quantum gates or state evolution that is equivalent to the action of~(\ref{LO Creation Operator Transformation}), but is capable of simulating large optical circuits consisting of many low-level components. The protocol is presented as follows; in section~\ref{Section of Facts} we will present a series of \textit{facts}. Proofs of these \textit{facts} are available in the appendix. Section~\ref{Section on Protocol} will present the protocol itself.

Before we begin, we can define $A(U)$ as the unitary matrix which represents the action of~(\ref{LO Creation Operator Transformation}) on a quantum state in the Fock basis~(\ref{LO State Fock Basis}). An output state of our total optical circuit $\ket{\psi^\prime}$ will determined by standard matrix-vector multiplication
\begin{equation}
\label{Matrix Vector Product}
\ket{\psi^\prime} = A(U) \ket{\psi}.
\end{equation}
If $N \ge 2$, the group of all linear optical operators, $ A(U) \in \textbf{A}$, is a proper (strict) subgroup of the general unitary group
\begin{equation}
\label{Proper Subgroup}
\textbf{A} \subset \textbf{GU}(d_H).
\end{equation}
In other words, not all quantum logic operations on multi-photon Fock states can be implemented via linear optical circuits. This is a consequence of the fact that linear entangling operations between photons are generally severely limited~\cite{Hong Ou Mandel}. 
\section{A Collection of Facts}
\label{Section of Facts}
\begin{center}\textit{Fact 1} \end{center}
For an optical circuit of $K$ number of components,
\begin{equation}
	\label{Fact 1}
A(U_K) A(U_{K-1}) \dots A(U_1) = A(U_1 U_2 \dots U_K).
\end{equation}
Each component $U_k$ can represent a simple beam splitter, phase shifter, or a general integrated circuit consisting of many low-level components. We can compile the $K$ optical hardware components via the matrix multiplication $U_1 U_2 \dots U_K$, rather than render each independently and multiply the $A(U_k)$ matrices.
\begin{center}\textit{Fact 2} \end{center}
Rewriting~(\ref{LO State Fock Basis}) as
\begin{equation}
\label{LO State Fock Vec Basis}
\ket{\psi} = \sum_{\vec{n}} c_{\vec{n}} \ket{\vec{n}}
\end{equation}
where
\begin{equation}
\ket{\vec{n}} = \ket{n_1,n_2,\dots,n_M}
\end{equation}
are the Fock states, we define
\begin{equation}
\label{m definition}
\ket{\vec{m}(\vec{n})} = \ket{m_1,m_2,\dots,m_N}
\end{equation}
as \textit{any} vector where $m_\alpha$ is the mode-location of photon number $\alpha$. There can be many vectors $\ket{\vec{m}(\vec{n})}$ for each $\ket{\vec{n}}$, since photons are generally indistinguishable and labeling them is an arbitrary process. We simply need to choose \textit{some} labeling and pick any valid $\ket{\vec{m}(\vec{n})}$. Then the elements of $A(U)$ are given by
\begin{eqnarray}
\label{Fact 2}
A(U)_{\vec{n}^\prime,\vec{n}} = \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \\ \small \nonumber \prod_{p=1}^{M} \frac{\sqrt{n_p^\prime !}}{\sqrt{n_p !}} \left[\sum_{perm(\vec{m}^\prime)} U_{m_1 m_1^\prime} U_{m_2 m_2^\prime} \dots U_{m_N m_N^\prime} \right] \outerproduct{\vec{n}^\prime}{\vec{n}} 
\end{eqnarray}
where the summation is over all distinct permutations of integer entries in the vector $\vec{m}^\prime$.
\begin{center}\textit{Fact 3} \end{center}
\fbox{
	\begin{minipage}{23em}
		If the input states to our optical circuit, $\ket{\psi}$, are known to be limited to some subspace of the physical Hilbert space of the system, we need only build relevant columns of $A(U)$.
	\end{minipage}
}
\newline
\newline
\newline
In practice, the input state to an optical circuit $\ket{\psi}$ will often be a simple, or even classical state e.g. $\ket{N,0,\dots,0_M}$. Alternatively, we may want to simulate an optical circuit where photons and modes are augmented in at some point. 
\begin{center}\textit{Fact 4} \end{center}
\fbox{
	\begin{minipage}{23em}
		If the output states of our optical circuit, $\ket{\psi^\prime}$ are then projected onto some subspace of the physical Hilbert space of the system, we need only build relevant rows of $A(U)$.
	\end{minipage}
}
\section{The Protocol}
\label{Section on Protocol}
Our protocol for simulating a linear optical quantum circuit is separated into an initialization and rendering stage. Initialization needs to only be performed once; one can then quickly render $A(U)$ for any particular optical circuit design, $U$. This allows fast, repeated simulation necessary for Monte-carlo techniques or numerical optimization.
\newline
\newline
\textbf{Initialization Stage:}
\newline
\newline
		(1)  Establish the Fock basis $\{\ket{\vec{n}} \}$ of our input state, $\ket{\psi}$ as in Eq.~(\ref{Matrix Vector Product}). Do not include basis states outside the span of $\ket{\psi}$, as per \textit{Fact 3}.
		\newline
		\newline
		(2) For each element of the basis set, $\ket{\vec{n}}$, construct a corresponding $\ket{\vec{m}(\vec{n})}$ as defined in Eq.~(\ref{m definition}).
		\newline
		\newline
		(3) Establish the Fock basis $\{\ket{\vec{n}^\prime}\}$ of our output state, $\ket{\psi^\prime}$ as in Eq.~(\ref{Matrix Vector Product}). Do not include basis states outside the (known) span of $\ket{\psi^\prime}$, as per \textit{Fact 4}.
		\newline
		\newline
		(4)  For each element of the basis set, $\ket{\vec{n}^\prime}$, construct a corresponding $\ket{\vec{m}^\prime(\vec{n}^\prime)}$ as defined in Eq.~(\ref{m definition}).
		\newline
		\newline
		(5) Store all $\vec{n}, \vec{n}^\prime, \vec{m}, \vec{m}^\prime$ as integer vectors in memory
		\newline
		\newline
\textbf{Rendering Stage:}
\newline
\newline
		(1)  Compile the total optical circuit composed of K components by performing the matrix multiplication $ U = U_1 U_2 \dots U_K $.
		\newline
		\newline
		(2) Render the matrix representation of the quantum operator $A(U)$ using Eq.~(\ref{Fact 2}) over all of the input basis states, $\{\ket{\vec{n}}\}$ and all of the output basis states $\{\ket{\vec{n}^\prime}\}$
\newline
\newline
For reference, an implementation of this algorithm is available on Github~\cite{GitHub}.
\section{Rail Encoding Qubits into Deterministic Blocks}
\label{Section Block Encoding}
It is well established that we can build any quantum logic operator acting on a state in the Fock basis using linear optical components if only a single photon is in the system;
\begin{equation}
\label{Isomorphism}
	\mbox{if } N=1, \quad \textbf{A} = \textbf{GU}(d_H).
\end{equation}
That is, we can build a universal quantum computer or fully decodible quantum channel in a single-photon rail encoding~\cite{Adami,Review Paper}. However, by forcing $N=1$, we sacrifice the scalability of our hardware; Eq.~(\ref{Hilbert Space Dimension}) simplifies to
\begin{equation}
d_H = M.
\end{equation}
To implement $j$ qubits, we would need to build a system of $M=2^j$ modes. Here, we group deterministic blocks of logical qubits together in order to establish scalability. For example, two qubits can be encoded into the $N=1,M=4$ system in Table~\ref{Two Qubit Encoding Table}.
\begin {table}[h]
\begin{center}
	\begin{tabular}{l*{6}{c}r} 
		Logical Qubit State      \quad \quad \quad     & Physical Fock State \\
		\hline 
		\quad \quad \quad $\ket{00}$     & $\ket{1,0,0,0}$ \\
		\quad \quad \quad $\ket{01}$            & $\ket{0,1,0,0}$ \\
		\quad \quad \quad $\ket{10}$            & $\ket{0,0,1,0}$ \\
		\quad \quad \quad $\ket{11}$            & $\ket{0,0,0,1}$ \\
	\end{tabular}
	\caption{ \label{Two Qubit Encoding Table} Two Qubit Single Photon Block Encoding}
\end{center}
\end{table}
We can then encode \textit{four} qubits into the $N=2,M=8$ system partitioned into two blocks as described in Table~\ref{Block Encoding Table}.
\begin {table}[h]
\begin{center}
	\begin{tabular}{l*{6}{c}r} 
		Logical Qubit State      \quad \quad \quad     & Physical Fock State \\
		\hline 
		\quad \quad \quad $\ket{0000}$     & $\ket{1,0,0,0,1,0,0,0}$ \\
		\quad \quad \quad $\ket{0001}$            & $\ket{1,0,0,0,0,1,0,0}$ \\
		\quad \quad \quad $\ket{0010}$           & 
		$\ket{1,0,0,0,0,0,1,0}$ \\
		\quad \quad \quad $\ket{0011}$           & 
		$\ket{1,0,0,0,0,0,0,1}$ \\
		\quad \quad \quad $\ket{0100}$           & 
		$\ket{0,1,0,0,1,0,0,0}$ \\
		\quad \quad \quad $\ket{0101}$           & 
		$\ket{0,1,0,0,0,1,0,0}$ \\
		\quad \quad \quad $\ket{0110}$           & 
		$\ket{0,1,0,0,0,0,1,0}$ \\
		\quad \quad \quad $\ket{0111}$            & $\ket{0,1,0,0,0,0,0,1}$ \\
		\quad \quad \quad $\ket{1000}$            & $\ket{0,0,1,0,1,0,0,0}$ \\
		\quad \quad \quad $\ket{1001}$            & $\ket{0,0,1,0,0,1,0,0}$ \\
		\quad \quad \quad $\ket{1010}$            & $\ket{0,0,1,0,0,0,1,0}$ \\
		\quad \quad \quad $\ket{1011}$            & $\ket{0,0,1,0,0,0,0,1}$ \\
		\quad \quad \quad $\ket{1100}$            & $\ket{0,0,0,1,1,0,0,0}$ \\
		\quad \quad \quad $\ket{1101}$            & $\ket{0,0,0,1,0,1,0,0}$ \\
		\quad \quad \quad $\ket{1110}$            & $\ket{0,0,0,1,0,0,1,0}$ \\
		\quad \quad \quad $\ket{1111}$            & $\ket{0,0,0,1,0,0,0,1}$ \\
	\end{tabular}
	\caption{ \label{Block Encoding Table} Four Qubits encoded into two single-photon blocks}
\end{center}
\end{table}
In this encoding we can apply any single qubit rotation or CNOT gate between logical qubits 1 and 2 or between logical qubits 3 and 4 through simple deterministic manipulation of a single photon~\cite{Adami}. The difficulty here will be to apply entangling operations between blocks. For example, we may want to apply the $\mbox{CNOT}_{1,4}$ gate where the control is qubit 1 and the target is qubit 4. This is an operation that will require the two photons in our system to interact; if a photon is contained in modes 3 or 4, we swap a photon between modes 5 and 6 or between modes 7 and 8. 
%The reader should note that the dimension of the Hilbert space of these block systems, $d_H$, is typically larger than the dimension of the computational subspace. We define the dimension of the computational subspace $d_C$, and in the case of Table~\ref{Block Encoding Table},
%\begin{equation}
%d_C = 16 \quad d_H = \frac{9!}{2! 7!} = 36
%\end{equation}
%All elements of the matrix representation of $\mbox{CNOT}_{1,4}$ outside of the 16 columns of the computational subspace are irrelevant since we assume all input states are contained in this subspace. All entries in the matrix representation of $\mbox{CNOT}_{1,4}$ outside the 16 computational rows but in the 16 computational columns are fixed at 0. This is to prevent any state from spreading out of the computational subspace.
%\section{Generalized Block Encoding}

Generalizing the 2-qubit block encoding in Table~\ref{Two Qubit Encoding Table}, we can encode $q$ qubits into a block of 1 photon and $2^q$ modes. Again, operations between pairs of logical qubits contained entirely within in a block are trivial to implement, but we will need to test our ability to realize communication between blocks. We assume a  mapping between logical qubit states and Fock states within a single block as in Table~\ref{q Qubit Block Encoding}.
\begin {table}[h]
\begin{center}
	\begin{tabular}{l*{6}{c}r} 
		Logical Qubit State      \quad \quad \quad     & Physical Fock State \\
		\hline 
		\quad \quad \quad $\ket{0\dots00}$     & $\ket{1,0,0,0,\dots,0}$ \\
		\quad \quad \quad $\ket{0\dots01}$            & $\ket{0,1,0,0,\dots,0}$ \\
		\quad \quad \quad $\ket{0\dots10}$            & $\ket{0,0,1,0,\dots,0}$ \\
		\quad \quad \quad $\ket{0\dots11}$            & $\ket{0,0,0,1,\dots,0}$ \\
		\quad \quad \quad \quad \enspace \vdots & \vdots \\
		\quad \quad \quad $\ket{1\dots11}$            & $\ket{0,0,0,0,\dots,1}$ \\
	\end{tabular}
	\caption{ \label{q Qubit Block Encoding} q Qubit Single Photon Block Encoding}
\end{center}
\end{table}
Without loss of generality, we can group two blocks together, choose the first qubit in the control block as a control qubit, and the last qubit in the target block as a target qubit. Then, we can generalize the $\mbox{CNOT}_{1,4}$ gate to the $\mbox{CNOT}_{first,last}$ gate, which swaps all sequential modes in the target block if a photon is in the second half of modes in the control block. This operation cannot be implemented through vanilla linear optics;
\begin{equation}
\mbox{CNOT}_{first,last} \notin \textbf{A}.
\end{equation}
In the special case of $q=1$, our block encoding reduces to the standard dual-rail encoded qubit\cite{Dual Rail}. In the KLM~\cite{KLM,Uskov} scheme, the $\mbox{CNOT}_{first,last}$ gate can be applied to dual-rail qubits using probabilistic partial measurements with success probability $p=2/27$. 
\section{Elementary Photon-Entangling Operations}
\label{Section Elementary Photon Entangling Operations}

 In practice, we find it useful to dismantle the $\mbox{CNOT}_{first,last}$ gate into a set of elementary entangling sub-operations. We can first examine the $\mathcal{C}_1$ sub-operation acting on three modes as defined in Table~\ref{One Control Two Targets}. 
\begin {table}[h]
\begin{center}
	\begin{tabular}{l*{6}{c}r} 
		$\ket{0,0,0}$  &  $\rightarrow$ & $\ket{0,0,0}$ \\ \\
		$\ket{0,0,1}$  & $\rightarrow$ & $\ket{0,0,1}$ \\
		$\ket{0,1,0}$ & $\rightarrow$ & $\ket{0,1,0}$ \\
		$\ket{1,0,0}$ & $\rightarrow$ & $\ket{1,0,0} $ \\ \\
		$\ket{1,0,1}$ & $\rightarrow$ & $\ket{1,1,0}$ \\
		$\ket{1,1,0}$ & $\rightarrow$ & $\ket{1,0,1}$ \\
	\end{tabular}
	\caption{ \label{One Control Two Targets} The $\mathcal{C}_1$  operation acting on three modes expressed as a transformation of Fock basis states. The first mode acts as the control while the second and third modes act as targets. We can build the $\mbox{CNOT}_{first,last}$ gate by applying this operation $2^{2 q -2}$ times.}
\end{center}
\end{table}
Here, we say the first mode is a control mode, while the second and third modes are target modes. We apply the $\mathcal{C}_1$  operator four times to build the $\mbox{CNOT}_{1,4}$ in $q=2$ by choosing the control mode as modes 3,4 in table~\ref{Block Encoding Table} and the two target modes as 5,6 and 7,8. The end result is the same as a $\mbox{CNOT}_{1,4}$; if a photon is in mode 3 or 4 we swap a photon between mode 5 and mode 6 or a photon between mode 7 and mode 8. More generally, a $\mbox{CNOT}_{first,last}$ gate for block size $q$ can be constructed by applying the $\mathcal{C}_1$  operation $2^{2q-2}$ times by setting the control mode to each of the modes in the second half of the control block, and the two target modes to every pair of modes in the target block. Because there will never be more than a single photon in a block, the basis states in Table~\ref{One Control Two Targets} will be the only possible inputs to the $\mathcal{C}_1$  transformation. If $\mathcal{C}_1$ is performed correctly, photon leakage between blocks will not occur.

Other entangling sub-operations we study here include the $\mathcal{C}_2$, $\mathcal{C}_3$, and $\mathcal{C}_4$ gates which are presented in Tables~\ref{Two Controls Two Targets}-\ref{Two Controls Four Targets}.
\begin {table}[h]
\begin{center}
	\begin{tabular}{l*{6}{c}r} 
		$\ket{0,0,0,0}$  &  $\rightarrow$ & $\ket{0,0,0,0}$ \\ \\
		$\ket{0,0,0,1}$  & $\rightarrow$ & $\ket{0,0,0,1}$ \\
		$\ket{0,0,1,0}$ & $\rightarrow$ & $\ket{0,0,1,0}$ \\
		$\ket{0,1,0,0}$ & $\rightarrow$ & $\ket{0,1,0,0} $ \\ 
		$\ket{1,0,0,0}$ & $\rightarrow$ & $\ket{1,0,0,0} $ \\ \\
		$\ket{1,0,0,1}$  & $\rightarrow$ & $\ket{1,0,1,0}$ \\
		$\ket{1,0,1,0}$ & $\rightarrow$ & $\ket{1,0,0,1}$ \\
		$\ket{0,1,0,1}$ & $\rightarrow$ & $\ket{0,1,1,0} $ \\ 
		$\ket{0,1,1,0}$ & $\rightarrow$ & $\ket{0,1,0,1} $ \\ \\
	\end{tabular}
	\caption{ \label{Two Controls Two Targets} The $\mathcal{C}_2$  operation acting on four modes expressed as a transformation of Fock basis states. The first two modes act as the controls while the last two modes act as targets. We can build the $\mbox{CNOT}_{first,last}$ gate by applying this operation $2^{2 q - 3}$ times.}
\end{center}
\end{table}
\begin {table}[h]
\begin{center}
	\begin{tabular}{l*{6}{c}r} 
		$\ket{0,0,0,0,0}$  &  $\rightarrow$ & $\ket{0,0,0,0,0}$ \\ \\
		$\ket{0,0,0,0,1}$  & $\rightarrow$ & $\ket{0,0,0,0,1}$ \\
		$\ket{0,0,0,1,0}$ & $\rightarrow$ & $\ket{0,0,0,1,0}$ \\
		$\ket{0,0,1,0,0}$ & $\rightarrow$ & $\ket{0,0,1,0,0} $ \\ 
		$\ket{0,1,0,0,0}$ & $\rightarrow$ & $\ket{0,1,0,0,0} $\\
		$\ket{1,0,0,0,0}$ & $\rightarrow$ & $\ket{1,0,0,0,0} $ \\ \\
		$\ket{1,0,0,0,1}$  & $\rightarrow$ & $\ket{1,0,0,1,0}$ \\
		$\ket{1,0,0,1,0}$  & $\rightarrow$ & $\ket{1,0,0,0,1}$ \\
		$\ket{1,0,1,0,0}$  & $\rightarrow$ & $\ket{1,1,0,0,0}$ \\
		$\ket{1,1,0,0,0}$  & $\rightarrow$ & $\ket{1,0,1,0,0}$ \\
	\end{tabular}
	\caption{ \label{One Control Four Targets} The $\mathcal{C}_3$ operation acting on five modes expressed as a transformation of Fock basis states. The first mode acts as the control while the last four modes act as targets. We can build the $\mbox{CNOT}_{first,last}$ gate by applying this operation $2^{2 q - 3}$ times.}
\end{center}
\end{table}
\begin {table}[h]
\begin{center}
	\begin{tabular}{l*{6}{c}r} 
		$\ket{0,0,0,0,0,0}$  &  $\rightarrow$ & $\ket{0,0,0,0,0,0}$ \\ \\
		$\ket{0,0,0,0,0,1}$  & $\rightarrow$ & $\ket{0,0,0,0,0,1}$ \\
		$\ket{0,0,0,0,1,0}$ & $\rightarrow$ & $\ket{0,0,0,0,1,0}$ \\
		$\ket{0,0,0,1,0,0}$ & $\rightarrow$ & $\ket{0,0,0,1,0,0} $ \\ 
		$\ket{0,0,1,0,0,0}$ & $\rightarrow$ & $\ket{0,0,1,0,0,0} $\\
		$\ket{0,1,0,0,0,0}$ & $\rightarrow$ & $\ket{0,1,0,0,0,0} $ \\
		$\ket{1,0,0,0,0,0}$ & $\rightarrow$ & $\ket{1,0,0,0,0,0} $ \\ \\
		$\ket{0,1,0,0,0,1}$  & $\rightarrow$ & $\ket{0,1,0,0,1,0}$ \\
		$\ket{0,1,0,0,1,0}$  & $\rightarrow$ & $\ket{0,1,0,0,0,1}$ \\
		$\ket{0,1,0,1,0,0}$  & $\rightarrow$ & $\ket{0,1,1,0,0,0}$ \\
		$\ket{0,1,1,0,0,0}$  & $\rightarrow$ & $\ket{0,1,0,1,0,0}$ \\
		$\ket{1,0,0,0,0,1}$  & $\rightarrow$ & $\ket{1,0,0,0,1,0}$ \\
		$\ket{1,0,0,0,1,0}$  & $\rightarrow$ & $\ket{1,0,0,0,0,1}$ \\
		$\ket{1,0,0,1,0,0}$  & $\rightarrow$ & $\ket{1,0,1,0,0,0}$ \\
		$\ket{1,0,1,0,0,0}$  & $\rightarrow$ & $\ket{1,0,0,1,0,0}$ \\
	\end{tabular}
	\caption{ \label{Two Controls Four Targets} The $\mathcal{C}_4$ operation acting on six modes expressed as a transformation of Fock basis states. The first two modes act as the controls while the last four modes act as targets. We can build the $\mbox{CNOT}_{first,last}$ gate by applying this operation $2^{2 q - 4}$ times.}
\end{center}
\end{table}
The focus of our work here was to test our ability to build these operators as probabilistic measurement-assisted transformations. By this, we mean to augment our optical computational state with an ancilla state, apply a linear optical transformation, and then do a partial projective measurement (refer to Fig.~\ref{Figure - PAULA Operator}). 
 \begin{figure}[h]
 	\centering
 	\includegraphics[width=0.5 \textwidth]{./PAULA.pdf}
 	\caption{A measurements assisted transformation described by $E$. An input computational state $\ket{\psi_c}$ and ancilla state $\ket{\psi_a}$ are processed through a linear circuit. Then, a partial measurement $P$ is performed and we are left with the output computational state $\ket{\psi_c^\prime}$.}
 	\label{Figure - PAULA Operator}
 \end{figure}
The total action of this non-unitary process can be written formally as a Kraus operator called the \textit{PAULA} operator which acts on any optical quantum state $\ket{\psi_{c}}$ composed of $N_c$ photons in $M_c$ modes contained to some computational subspace;
\begin{equation}
\label{Kraus Paula Operator}
E = P A(U) L_a
\end{equation} 
\begin{equation}
\ket{\psi_{c}^\prime} = E \ket{\psi_{c}}
\end{equation}
and then re-normalizing.  $L_a$ is the operator defined by
\begin{equation}
\label{Ancilla Linker}
L_a \ket{\psi_{c}} = \ket{\psi_a} \otimes \ket{\psi_{c}} \quad  \forall \quad \ket{\psi_{c}}
\end{equation}
where where $\ket{\psi_a}$ is a normalized ancilla state composed of $N_a$ photons in $M_a$ optical modes. The matrix representation of $L_a$ is sparse and satisfies $L_a^\dagger L_a = I$.
$A(U)$ is the standard, general unitary linear optical transformation as defined in Eq.~\ref{Fact 2} where $N=N_c+N_a$ and $M=M_c+M_a$. $P$ is a partial projective measurement over the ancilla modes. We assume the projection operator is the outer product of some Fock state
\begin{equation}
P = \outerproduct{\vec{n}_a}{\vec{n}_a}
\end{equation}
containing the same number of photons and modes in the ancilla state, $N_a,M_a$. $E$ therefore preserves photon and mode number. In accordance with \textit{Facts 3 and 4}, we do not construct the entire matrix $A(U)$ - only the columns mapped to by $L_a \ket{\psi_{c}}$ and the rows left after the projection $P$. We define $d_c$ as the dimension of the subspace all input states to our circuit are contained in, and $d_c^\prime$ as the full physical Hilbert space of our computational states;
\begin{equation}
	d_c^\prime = \frac{(N_c+M_c-1)!}{N_c! (M_c-1)!}
\end{equation}
$E$ can then be represented as a $d_c^\prime$ by $d_c$ rectangular matrix.

A measure of gate fidelity between a \textit{PAULA} operator and unitary target operation $T$ can be defined by
\begin{equation}
\label{Gate Fidelity}
F(E,T) = \frac{\Re[\tr(E^\dagger T)]}{\sqrt{d_c \tr(E^\dagger E)} }.
\end{equation}
The probability of having successfully applied $E$ after projective measurement $P$ is given by
\begin{equation}
\label{Success Probability} 
S(E) = \frac{\tr(E^\dagger E)}{d_c}
\end{equation}
near $F(E,T) \rightarrow 1$.

To construct the $\mathcal{C}_1$ operation, we simultaneously maximize the gate fidelity and success probability for each  $N_c=0,1,2$ \textit{separately} over the same quantum optical circuit $U$ and ancilla state $\ket{\psi_a}$. That is, we establish an ideal target $T_{N_c}$ and Kraus \textit{PAULA} operator $E_{N_c}$ for each photon number and attempt to find any particular $U$ and $\ket{\psi_a}$ such that all $F(E_{N_c},T_{N_c}) \rightarrow 1$ with optimal $S(E_{N_c})$. We will demonstrate the details of this in the following section for $\mathcal{C}_1$. The general idea can easily be extended $\mathcal{C}_2 \dots \mathcal{C}_4$, and we omit detailed discussion of those cases from this paper.
\section{Numerical Testing of $\mathcal{C}_1$}
\label{Section Numerical Testing}
We get the transformation acting on a system of $N_c=0$ photons for free
\begin{equation}
\label{Free Operation}
\ket{0,0,0} \rightarrow \ket{0,0,0}
\end{equation}
If only a single photon is in our subsystem of modes, $N_c=1$, we strive for a target operator
\begin{equation}
\label{T1 1C2T}
T_1=	\begin{pmatrix} 1 & 0 & 0  \\ 0 & 1 & 0  \\ 0 & 0 & 1   \end{pmatrix}  
\end{equation}
\begin{equation}
d_C = d_C^\prime = 3
\end{equation}
in the basis
\begin{equation}
\{ \ket{\vec{n}_C} \} = \{ \ket{\vec{n}_C^\prime} \} = \{ \ket{0,0,1},\ket{0,1,0},\ket{1,0,0} \}.
\end{equation}
If two photons are in our subspace, $N_c=2$, we strive for a target operator 
\begin{equation}
\label{T2 1C2T}
T_2=\begin{pmatrix} 0 & 1  \\ 1 & 0  \\ 0 & 0 \\ 0 & 0 \\ 0 & 0 \\ 0 & 0   \end{pmatrix}.  
\end{equation}
\begin{equation}
d_C = 2 \quad d_C^\prime = 6
\end{equation}
in the basis
\begin{equation}
\{ \ket{\vec{n}_C} \} = \{ \ket{1,0,1},\ket{1,1,0} \}
\end{equation}
\begin{eqnarray}
& \{ \ket{\vec{n}^\prime_C } \} = \{ \ket{1,0,1},\ket{1,1,0}, \\ &\ket{2,0,0},\ket{0,2,0},\ket{0,1,1},\ket{0,0,2} \}. \nonumber
\end{eqnarray}
We define the \textit{PAULA} operators separately for each target
\begin{equation}
E_1(U,L_a) \quad \quad \quad E_2(U,L_a)
\end{equation}
and numerically maximize the function
\begin{equation}
\label{Merit Function For Blocks}
\small f(U,\psi_a) = F(E_1,T_1) + F(E_2,T_2) +\epsilon (S(E_1) + S(E_2) )
\end{equation}
where $\epsilon \in \{0,1\}$ is just a real numerical weight for the optimization. We step iteratively through parameters $\epsilon$, $N_a$, $M_a$, and $P$ and repeat maximization of Eq.~(\ref{Merit Function For Blocks}) to find global solutions.

Any difference in global phases between the operators in~(\ref{Free Operation}), (\ref{T1 1C2T}) and (\ref{T2 1C2T}) will cause an unwanted relative phase shift between Fock basis states under the full transformation $\mathcal{C}_1$. For this reason, we use the gate fidelity in Eq.~(\ref{Gate Fidelity}) which accounts for a global phase difference between $E$ and $T$. 
\section{Results}
\subsection{The Entangling Operation $\mathcal{C}_1$}
This physical operation acting on three modes is of particular importance; it can be applied a single time to two qubits encoded in the dual rail ($q=1$) in order to apply an entangling $\mbox{CNOT}$ gate between them. After extensive numerical optimization of Eq.~\ref{Merit Function For Blocks}, we find the same optimal solution found in~\cite{Uskov}.
\begin{eqnarray}
& F(E_1,T_1)_{max} = F(E_2,T_2)_{max} = 1 \nonumber \\
& S_{max}(E_1) = S_{max}(E_2) = 2/27 \\
& N_a,M_a=2 \nonumber \\
& P = \outerproduct{11}{11} \nonumber	
\end{eqnarray}
Increasing the number of ancilla resources beyond $N_a,M_a=2$ does not improve the success probability as far as we are able to test ($N_a,M_a \le 8$). Thus, for a block size of $q$ qubits, we find a maximum probability of successfully applying a $\mbox{CNOT}_{first,last}$ gate composed of the $\mathcal{C}_1$ operation using measurement-assisted transformations to be
\begin{equation}
\label{1C2T Result}
p = (2/27)^{2^{2q-2}}
\end{equation}
\subsection{The Entangling Operation $\mathcal{C}_2$}
We find the optimal solution;
\begin{eqnarray}
& F(E_1,T_1)_{max} = F(E_2,T_2)_{max} = 1 \nonumber \\
&S_{max}(E_1) = S_{max}(E_2) = 0.0221391 \\
&N_a = 3,M_a=4 \nonumber \\
&P = \outerproduct{1110}{1110} \nonumber	
\end{eqnarray}
For a block size of $q$ qubits, we find a maximum probability of successfully applying a $\mbox{CNOT}_{first,last}$ gate composed of the operation $\mathcal{C}_2$ using measurement-assisted transformations to be
\begin{equation}
\label{2C2T Result}
p = (0.0221391)^{2^{2q-3}}
\end{equation}
\subsection{The Entangling Operation $\mathcal{C}_3$}
We find the optimal solution;
\begin{eqnarray}
& F(E_1,T_1)_{max} = F(E_2,T_2)_{max} = 1 \nonumber \\
& S_{max}(E_1) = S_{max}(E_2) = 0.0221266 \\
& N_a = 3,M_a=4 \nonumber \\
& P = \outerproduct{1110}{1110} \nonumber	
\end{eqnarray}
For a block size of $q$ qubits, we find a maximum probability of successfully applying a $\mbox{CNOT}_{first,last}$ gate composed of the operation $\mathcal{C}_3$ using measurement-assisted transformations to be
\begin{equation}
\label{1C4T Result}
p = (0.0221266)^{2^{2q-3}}
\end{equation}
\subsection{The Entangling Operation $\mathcal{C}_4$}
We find the optimal solution;
 \begin{eqnarray}
 & F(E_1,T_1)_{max} = F(E_2,T_2)_{max} = 1 \nonumber\\
 & S_{max}(E_1) = S_{max}(E_2) = 0.00691511 \\
 & N_a = 4,M_a=4 \nonumber\\
 & P = \outerproduct{1111}{1111} \nonumber	
 \end{eqnarray}
For a block size of $q$ qubits, we find a maximum probability of successfully applying a $\mbox{CNOT}_{first,last}$ gate composed of the operation $\mathcal{C}_4$ using measurement-assisted transformations to be
 \begin{equation}
 \label{2C4T Result}
 p = (0.00691511)^{2^{2q-4}}
 \end{equation}
 \section{Discussion}
 \label{Section Conclusion}
 We observe a promising increase in success probability of applying the $\mbox{CNOT}_{first,last}$ gate as we increase the size of our sub-operation components; refer to Fig.~\ref{Figure - Block Encoding Results}. 
 \begin{figure}[h]
  	\centering
  	\includegraphics[width=0.5 \textwidth]{./blockencodingresults.pdf}
  	\caption{Maximum Observed Success probabilities for implementing a full $\mbox{CNOT}_{first,last}$ gate composed entirely of the sub-operations $\mathcal{C}_1$, $\mathcal{C}_2$, $\mathcal{C}_3$, $\mathcal{C}_4$, for block size $q$. THIS NEEDS TO BE CONVERTED TO LOG SCALE THINK ABOUT IT}
  	\label{Figure - Block Encoding Results}
  \end{figure}
Even within the reach of our numerical simulations, we find an improvement over standard KLM for applying entangling operations within the context of some quantum algorithms. For example, the simple quantum circuit 
 \begin{eqnarray}
 \small & \mbox{CNOT}^3 = \\ \small \nonumber & (I \otimes I \otimes \mbox{CNOT}) \cdot (I \otimes  \mbox{CNOT} \otimes I) \cdot (\mbox{CNOT} \otimes I \otimes I)
 \end{eqnarray}
 acting on four qubits is presented in Fig.~\ref{Three CNOTs}. Through the standard KLM protocol acting on qubits encoded in the dual-rail, each CNOT gate can be implemented with success probabilty $2/27$ using ancilla resources $N_a,M_a=2$. The total cost of the $\mbox{CNOT}^3$ gate; a success probability of $(2/27)^3$ using ancilla resources $ N_a,M_a = 6 $. Grouping these four qubits into two deterministic blocks of two qubits, $q=2$, we can apply the same operation with a success probability of $0.00691511$ using ancilla resources $ N_a,M_a=4 $. This is almost a twenty-fold improvement, while using less ancillas.
 \begin{figure}[ht]
 	\centering
 	\includegraphics[width=0.25 \textwidth]{./ThreeCNOTs.pdf}
 	\caption{The quantum circuit $\mbox{CNOT}^3$ acting on four qubits.}
 	\label{Three CNOTs}
 \end{figure}

 The trend in Fig.~\ref{Figure - Block Encoding Results} suggests order of magnitude improvement in success probability as we increase the size of entangling sub-operations between blocks. Future work will further increase the size of our simulations; a $\mbox{CNOT}_{first,last}$ gate built from larger sub-operations for block size $q \ge 3$ may have significant implications for linear optical quantum computing.
\acknowledgments
We are thankful for helpful discussions with N. Sparks, J. Shipman and E. Knudson. This research was supported in part using high performance computing (HPC) resources and services provided by Technology Services at Tulane University, New Orleans, LA.
\appendix
\section{Proof of \textit{Fact 1}}
\label{Proof of Fact 1}
\textit{Fact 1} can be proved by induction. The base case is trivial; for a lone unitary matrix $U_1$,~(\ref{Fact 1}) reads
\begin{equation}
	A(U_1) = A(U_1)
\end{equation}
We can then assume
\begin{equation}
\label{Inductive Step}
	A(U_{P-1}) A(U_{P-2}) \dots A(U_1) = A(U_1 U_2 \dots U_{P-1})
\end{equation}
That is, applying the left hand side of~(\ref{Inductive Step}) is equivalent to the total transformation
\begin{equation}
	\hat{a}^\dagger_\alpha \rightarrow \sum_\beta (U_1 U_2 \dots U_{P-1})_{\alpha,\beta} \enspace \hat{a}^\dagger_\beta
\end{equation}
Now we add one final optical component and apply the transformation $A(U_P)$. Our total transformation is now
\begin{equation}
	\hat{a}^\dagger_\alpha \rightarrow \sum_\beta (U_1 U_2 \dots U_{P-1})_{\alpha,\beta} \Big(\sum_\gamma U_{\beta,\gamma}^P \hat{a}^\dagger_\gamma \Big)
\end{equation}
where $U_{\beta,\gamma}^P$ are the $\beta,\gamma$ elements of $U_P$. Then,
\begin{eqnarray}
\hat{a}^\dagger_\alpha \rightarrow \sum_{\beta,\gamma} (U_1 U_2 \dots U_{P-1})_{\alpha,\beta} U^P_{\beta,\gamma} \hat{a}^\dagger_\gamma
\\*
\hat{a}^\dagger_\alpha \rightarrow \sum_\gamma (U_1 U_2 \dots U_P)_{\alpha,\gamma} \hat{a}^\dagger_\gamma \quad
\end{eqnarray}
which is equivalent to $A(U_1 U_2 \dots U_n). \quad \quad\blacksquare $
\section{Proof of \textit{Fact 2}}
\label{Proof of Fact 2}
We can write~(\ref{LO State Fock Vec Basis}) in the $\ket{\vec{m}(\vec{n})}$ basis;
\begin{equation}
\ket{\psi} = \sum_{\vec{n}} c_{\vec{n}} \ket{\vec{m}(\vec{n})}
\end{equation}
We note that because photons are Bosons, and are indistinguishable, this change of basis is not well-defined. The same Fock state $\ket{\vec{n}}$ can map to multiple $\ket{\vec{m}(\vec{n})}$ states. This mapping is injective, however. No matter which mapping we choose for each basis state, no information about the state $\ket{\psi}$ is lost. Thus, we are free to pick any mapping we want for each basis Fock state. Then
\begin{equation}
\ket{\psi} = \sum_{\vec{n}} \frac{\vec{c}_n}{\prod_{p=1}^{M} \sqrt{n_p !}} \hat{a}_{m_1}^\dagger \hat{a}_{m_2}^\dagger \dots \hat{a}_{m_N}^\dagger \ket{\vec{0}}
\end{equation}
We define the vectors
\begin{equation}
\vec{U}_\alpha = (U_{\alpha 1},U_{\alpha 2},\dots U_{\alpha M})
\end{equation}
in the basis
\begin{equation}
\{ \hat{a}_{1}^\dagger,\hat{a}_{2}^\dagger, \dots, \hat{a}_{M}^\dagger \}
\end{equation}
then
\begin{eqnarray}
\label{Fact 2 Proof Checkpoint}
& \ket{\psi^\prime} = A(U) \ket{\psi} =  \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \\ & \nonumber
\sum_{\vec{n}} \frac{c_{\vec{n}}}{\prod_{p=1}^{M} \sqrt{n_p !}} \enspace \vec{U}_{m_1} \otimes \vec{U}_{m_2} \otimes \dots \otimes \vec{U}_{m_N} \ket{\vec{0}}
\end{eqnarray}
The tensor product in~(\ref{Fact 2 Proof Checkpoint}) will return a massive vector of $M^N$ entries. We can use the commutative property of the creation operators to compress it;
\begin{equation}
[\hat{a}_i ^ \dagger,\hat{a}_j ^ \dagger] = 0 \quad \forall \quad i,j
\end{equation}
\begin{eqnarray}
 \ket{\psi^\prime} = \sum_{\vec{n}} \frac{c_{\vec{n}}}{\prod_{p=1}^{M} \sqrt{n_p !}} \cdot \quad \quad \quad \quad \quad \quad \quad \quad \quad \\  \nonumber \sum^M_{\substack{m_1^\prime = 1\\
		m_2^\prime = m_1^\prime\\
		\vdots \\
		m_N^\prime = m_{N-1}^\prime}}
\left[ \sum_{perm(\vec{m}^\prime)} U_{m_1 m_1^\prime} \dots U_{m_N m_N^\prime} \right] \hat{a}_{m_1^\prime}^\dagger \dots \hat{a}_{m_N^\prime}^\dagger \ket{\vec{0}}
\end{eqnarray}
Finally, we define $\ket{\vec{n}^\prime(\vec{m}^\prime)}$ as the photo-counting result of $\hat{a}_{m_1^\prime}^\dagger \dots \hat{a}_{m_N^\prime}^\dagger \ket{\vec{0}}$, or the Fock state mapped to by each term in the summation over elements of $\ket{\vec{m}^\prime}$
\begin{eqnarray}
\label{Fact 2 Proof Checkpoint 2}
\small \ket{\psi^\prime} = \sum_{\vec{n}} c_{\vec{n}}  \cdot \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad  \\ \sum^M_{\substack{m_1^\prime = 1\\
		m_2^\prime = m_1^\prime\\
		\vdots \\
		m_N^\prime = m_{N-1}^\prime}}
\left[ \prod_{p=1}^{M} \frac{\sqrt{n_p^\prime(\vec{m}^\prime) !}}{ \sqrt{n_p !}} \right] \left[ \sum_{perm(\vec{m}^\prime)} U_{m_1 m_1^\prime} \dots U_{m_N m_N^\prime} \right] \nonumber \\
\cdot \ket{\vec{n}^\prime (\vec{m}^\prime) } \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \nonumber
\end{eqnarray}
We recognize~(\ref{Fact 2 Proof Checkpoint 2}) as the result of a matrix vector product~(\ref{Matrix Vector Product}) if we define $A(U)$ as in~(\ref{Fact 2}).  $ \blacksquare $

\begin{thebibliography}{99}

\bibitem{KLM}  E. Knill, R. Laflamme, G. J. Milburn, Nature (London) 409, 46 (2001).

\bibitem{GitHub} https://github.com/jsmith74/linear-optics

\bibitem{Uskov} Uskov Et. Al.
Phys. Rev. A 79, 042326 (2009).

\bibitem{Adami} https://arxiv.org/abs/quant-ph/9806048

\bibitem{Review Paper} Kok Et. Al.
Rev. Mod. Phys. 79, 135 (2007).

\bibitem{EIGEN} http://eigen.tuxfamily.org/

\bibitem{Dual Rail} Dual Rail

\bibitem{Hong Ou Mandel} Hong Ou Mandel

\end{thebibliography}


\end{document}
